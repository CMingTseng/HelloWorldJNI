<div align="center">
  <h1>JNI with CMake Project Example</h1>
</div>
<p align="center">
  <strong>(繁體中文)</strong> | <a href="#english">English</a>
</p>

## 專案簡介

這是一個範例專案，展示如何透過 **JNI (Java Native Interface)** 在 Java/Kotlin 專案中呼叫 C/C++ 程式碼。專案使用 **CMake** 來編譯 C/C++ 原始碼，並將其建置為動態連結函式庫 (.so, .dll, .dylib)，以便 Java 執行環境 (JVM) 載入和使用。

此範例特別考慮了 Android 和非 Android (例如標準桌面應用) 的開發環境。

## 專案結構

此專案的目錄結構如下，特別將 C/C++ 相關檔案放在 `src/main/java` 路徑下，以符合附圖中的範例結構。

```
HelloWorldJNI
├── app
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── org
│                   └── kmp
│                       └── kmp
│                           ├── HelloWorldJNI.java  // Java 類別，宣告 native 方法
│                           └── jni                 // JNI 程式碼目錄
│                               ├── CMakeLists.txt  // CMake 建置腳本
│                               ├── HelloWorld.cpp  // C++ 原始碼
│                               └── HelloWorld.h    // C++ 標頭檔
└── build.gradle.kts
```

---

## 需求與環境設定 (Prerequisites)

在開始之前，請確保您的開發環境已滿足以下要求。

### 1. JDK (Java Development Kit)
所有使用者都需要安裝 JDK。

- **設定 `JAVA_HOME` 環境變數**:
    - **Windows**: `C:\Program Files\Java\jdk-17` (路徑依您的安裝版本而定)
    - **macOS/Linux**: `/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home`

### 2. Android 開發者
如果您是使用 Android Studio 進行開發，事情會簡單很多。

- **Android SDK**: Android Studio 會自動管理 NDK (Native Development Kit) 和 CMake。您只需要確保在 **SDK Manager** 中已下載並安裝所需的 NDK 和 CMake 版本即可。`build.gradle.kts` 中的設定會自動使用它們。

### 3. 非 Android 開發者 (Windows/macOS/Linux)

#### A. 安裝 CMake
如果您的系統中沒有 CMake，需要手動安裝。

- **官方下載位置**: [https://cmake.org/download/](https://cmake.org/download/)
- 下載並安裝適合您作業系統的版本。
- **設定 `CMAKE_HOME` 環境變數** (可選，但建議):
    - **Windows**: `C:\Program Files\CMake`
    - **macOS/Linux**: `/usr/local/` 或您安裝的路徑。
- 最後，將 CMake 的 `bin` 目錄加入系統的 `PATH` 環境變數中。

#### B. 安裝 C/C++ 編譯器 (以 Windows 為例)
在 Windows 上，您需要一個 C/C++ 編譯器，例如 GCC。**MinGW-w64** 是最常見的選擇。推薦使用 **MSYS2** 來安裝，因為它能提供一個乾淨且易於管理的環境。

- **MSYS2 (推薦)**
    1. **下載與安裝**: 前往官方網站 [https://www.msys2.org/](https://www.msys2.org/) 並依照指示安裝。
    2. **安裝 MinGW-w64 toolchain**: 開啟 MSYS2 終端機，執行以下指令來安裝 64 位元的 GCC 工具鏈：
       ```bash
       # 1. 更新套件資料庫與基礎套件
       pacman -Syu
       # 2. (如果需要) 關閉終端機，重開一個新的，然後再次更新
       pacman -Su
       # 3. 安裝 MinGW-w64 GCC 工具鏈
       pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain
       ```
- **Standalone (獨立安裝)**
    - 如果您不想使用 MSYS2，也可以從 [winlibs.com](https://winlibs.com/) 下載獨立的 MinGW-w64 發行版，解壓縮後即可使用。

- **設定 `MinGW_HOME` 與 `PATH`**:
    1. 設定一個名為 `MinGW_HOME` 的環境變數，指向您的 MinGW-w64 安裝路徑 (例如 `C:\msys64\mingw64`)。
    2. 將 `%MinGW_HOME%\bin` 加入到系統的 `PATH` 環境變數中。

---

## 範例程式碼

這是一個 "Hello from C++ World!" 的簡單範例。

### 1. Java (`HelloWorldJNI.java`)
這個 Java 類別載入動態函式庫並宣告一個 `native` 方法。

```java
package org.kmp.kmp;

public class HelloWorldJNI {

    // 載入由 CMake 編譯產生的動態函式庫
    // 在 Windows 上會是 'HelloWorldJNI.dll'
    // 在 Linux 上會是 'libHelloWorldJNI.so'
    static {
        System.loadLibrary("HelloWorldJNI");
    }

    // 宣告一個 native 方法，這個方法的實作在 C++ 中
    public native String sayHello();

    public static void main(String[] args) {
        String message = new HelloWorldJNI().sayHello();
        System.out.println(message);
    }
}
```

### 2. C++ 標頭檔 (`jni/HelloWorld.h`)
```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class org_kmp_kmp_HelloWorldJNI */

#ifndef _Included_org_kmp_kmp_HelloWorldJNI
#define _Included_org_kmp_kmp_HelloWorldJNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     org_kmp_kmp_HelloWorldJNI
 * Method:    sayHello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_org_kmp_kmp_HelloWorldJNI_sayHello
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

### 3. C++ 原始碼 (`jni/HelloWorld.cpp`)
JNI 函式的實作。函式名稱必須符合 `Java_套件名稱_類別名稱_方法名稱` 的格式。

```cpp
#include "HelloWorld.h"
#include <string>

JNIEXPORT jstring JNICALL Java_org_kmp_kmp_HelloWorldJNI_sayHello
  (JNIEnv *env, jobject obj) {
    std::string hello = "Hello from C++ World!";
    return env->NewStringUTF(hello.c_str());
}
```

### 4. CMake 建置腳本 (`jni/CMakeLists.txt`)
這個腳本告訴 CMake 如何編譯 C++ 程式碼並建立動態函式庫。

```cmake
# 設定 CMake 最低版本要求
cmake_minimum_required(VERSION 3.10)

# 專案名稱
project(HelloWorldJNI)

# 新增一個函式庫目標
# SHARED 表示建立動態連結函式庫 (.dll/.so)
# HelloWorld.cpp 是我們的原始碼檔案
add_library(
        HelloWorldJNI
        SHARED
        HelloWorld.cpp)

# 尋找 JNI 函式庫
# 這能讓 CMake 找到 jni.h 等必要的標頭檔
find_package(JNI REQUIRED)

# 如果找到了 JNI，則將標頭檔路徑加入
if (JNI_FOUND)
    target_include_directories(HelloWorldJNI PUBLIC ${JNI_INCLUDE_DIRS})
endif()
```

---

## 建置與執行

### 1. Gradle 配置 (`app/build.gradle.kts`)

在 Android 專案中，我們使用 `externalNativeBuild` 區塊來整合 CMake。

```kotlin
// app/build.gradle.kts
//添加以下 Tasks 到 build.gradle.kts
tasks.register<Exec>("buildNativeLib") 
```

### 2. 在 IDE 中執行

1.  **同步 Gradle**: 在 `build.gradle.kts` 中加入設定後，IDE (Android Studio / IntelliJ IDEA) 會提示您同步專案。
2.  **執行**: 直接在 側邊欄中Gradle 展開 找到 application 點擊 `Run` 即可執行 `HelloWorldJNI.java` 的 `main` 方法。

您應該會在控制台看到以下輸出：
```
Hello from C++ World!
```

---
<br/>
<br/>
<br/>
---

<a name="english"></a>
<div align="center">
  <h1>JNI with CMake Project Example</h1>
</div>
<p align="center">
  <a href="#">繁體中文 (Traditional Chinese)</a> | <strong>English</strong>
</p>


## Project Introduction

This is a sample project demonstrating how to call C/C++ code from a Java/Kotlin project using **JNI (Java Native Interface)**. The project uses **CMake** to compile the C/C++ source code and build it into a shared library (.so, .dll, .dylib), which can then be loaded and used by the Java Virtual Machine (JVM).

This example is designed for both Android and non-Android (e.g., standard desktop applications) development environments.

## Project Structure

The directory structure of this project is as follows, with C/C++ related files placed under the `src/main/java` path to match the provided image.

```
HelloWorldJNI
├── app
│   ├── build.gradle.kts
│   └── src
│       └── main
│           └── java
│               └── org
│                   └── kmp
│                       └── kmp
│                           ├── HelloWorldJNI.java  // Java class declaring the native method
│                           └── jni                 // Directory for JNI code
│                               ├── CMakeLists.txt  // CMake build script
│                               ├── HelloWorld.cpp  // C++ source code
│                               └── HelloWorld.h    // C++ header file
└── build.gradle.kts
```

---

## Prerequisites

Before you begin, please ensure your development environment meets the following requirements.

### 1. JDK (Java Development Kit)
A JDK installation is required for all users.

- **Set `JAVA_HOME` Environment Variable**:
    - **Windows**: `C:\Program Files\Java\jdk-17` (path may vary depending on your installed version)
    - **macOS/Linux**: `/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home`

### 2. For Android Developers
If you are developing with Android Studio, the process is much simpler.

- **Android SDK**: Android Studio automatically manages the NDK (Native Development Kit) and CMake. You just need to ensure that the required NDK and CMake versions are downloaded and installed via the **SDK Manager**. The settings in `build.gradle.kts` will use them automatically.

### 3. For Non-Android Developers (Windows/macOS/Linux)

#### A. Install CMake
If CMake is not already installed on your system, you will need to install it manually.

- **Official Download Location**: [https://cmake.org/download/](https://cmake.org/download/)
- Download and install the version appropriate for your operating system.
- **Set `CMAKE_HOME` Environment Variable** (optional, but recommended):
    - **Windows**: `C:\Program Files\CMake`
    - **macOS/Linux**: `/usr/local/` or your custom installation path.
- Finally, add CMake's `bin` directory to your system's `PATH` environment variable.

#### B. Install a C/C++ Compiler (Windows Example)
On Windows, you need a C/C++ compiler, such as GCC. **MinGW-w64** is the most common choice. It is recommended to install it via **MSYS2**, which provides a clean and manageable environment.

- **MSYS2 (Recommended)**
    1. **Download and Install**: Go to the official website [https://www.msys2.org/](https://www.msys2.org/) and follow the installation instructions.
    2. **Install the MinGW-w64 toolchain**: Open the MSYS2 terminal and run the following commands to install the 64-bit GCC toolchain:
       ```bash
       # 1. Update the package database and base packages
       pacman -Syu
       # 2. (If needed) Close the terminal, open a new one, and update again
       pacman -Su
       # 3. Install the MinGW-w64 GCC toolchain
       pacman -S --needed base-devel mingw-w64-ucrt-x86_64-toolchain
       ```
- **Standalone Installation**
    - If you prefer not to use MSYS2, you can also download a standalone MinGW-w64 distribution from [winlibs.com](https://winlibs.com/), which can be used after extraction.

- **Set `MinGW_HOME` and `PATH`**:
    1. Create an environment variable named `MinGW_HOME` pointing to your MinGW-w64 installation path (e.g., `C:\msys64\mingw64`).
    2. Add `%MinGW_HOME%\bin` to your system's `PATH` environment variable.

---

## Code Example

Here is a simple "Hello from C++ World!" example.

### 1. Java (`HelloWorldJNI.java`)
This Java class loads the shared library and declares a `native` method.

```java
package org.kmp.kmp;

public class HelloWorldJNI {

    // Load the shared library compiled by CMake
    // On Windows, this will be 'HelloWorldJNI.dll'
    // On Linux, this will be 'libHelloWorldJNI.so'
    static {
        System.loadLibrary("HelloWorldJNI");
    }

    // Declare a native method implemented in C++
    public native String sayHello();

    public static void main(String[] args) {
        String message = new HelloWorldJNI().sayHello();
        System.out.println(message);
    }
}
```

### 2. C++ Header (`jni/HelloWorld.h`)
```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class org_kmp_kmp_HelloWorldJNI */

#ifndef _Included_org_kmp_kmp_HelloWorldJNI
#define _Included_org_kmp_kmp_HelloWorldJNI
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     org_kmp_kmp_HelloWorldJNI
 * Method:    sayHello
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_org_kmp_kmp_HelloWorldJNI_sayHello
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

### 3. C++ Source (`jni/HelloWorld.cpp`)
Implementation of the JNI function. The function name must follow the `Java_PackageName_ClassName_MethodName` format.

```cpp
#include "HelloWorld.h"
#include <string>

JNIEXPORT jstring JNICALL Java_org_kmp_kmp_HelloWorldJNI_sayHello
  (JNIEnv *env, jobject obj) {
    std::string hello = "Hello from C++ World!";
    return env->NewStringUTF(hello.c_str());
}
```

### 4. CMake Build Script (`jni/CMakeLists.txt`)
This script tells CMake how to compile the C++ code and create the shared library.

```cmake
# Set the minimum required version of CMake
cmake_minimum_required(VERSION 3.10)

# Project name
project(HelloWorldJNI)

# Add a library target
# SHARED indicates a shared library (.dll/.so)
# HelloWorld.cpp is our source file
add_library(
        HelloWorldJNI
        SHARED
        HelloWorld.cpp)

# Find the JNI libraries
# This allows CMake to find necessary headers like jni.h
find_package(JNI REQUIRED)

# If JNI is found, add the include directories
if (JNI_FOUND)
    target_include_directories(HelloWorldJNI PUBLIC ${JNI_INCLUDE_DIRS})
endif()
```

---

## Build and Run

### 1. Gradle Configuration (`app/build.gradle.kts`)

In an Android project, we use the `externalNativeBuild` block to integrate CMake.

```kotlin
// app/build.gradle.kts
//add Tasks into build.gradle.kts
tasks.register<Exec>("buildNativeLib") 
```

### 2. Run from the IDE

1.  **Sync Gradle**: After adding the configuration to `build.gradle.kts`, your IDE (Android Studio / IntelliJ IDEA) will prompt you to sync the project.
2.  **Run By Gradle**: Expand Gradle `application` `run` in your IDE to execute the `main` method of `HelloWorldJNI.java`.

You should see the following output in your console:
```
Hello from C++ World!
```